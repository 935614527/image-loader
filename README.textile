h1. ImageLoader

ImageLoader is a simple library that helps you to fetch, load and cache images in Android apps. 
It downloads images away from the UI thread and caches with a two-level in-memory/SD card cache.

h2. Recent changes

h3. 1.5.6-SNAPSHOT

* Removed necessity to set a service in the manifest for the clean up, everything is done in the BasicFileManager with a background thread.

h3. 1.5.5

* Bug fixes
* New DirectLoader utility to directly download images (do not use on main thread)

h3. 1.5.2

* Added support to load a cached small image as the preview for a larger image

h3. 1.5.1

* Improved concurrent loader
* Change SD card cache directory to respect Android SDK guidelines
* Improved LruBitmapCache

h2. Using the library

The demo project is a good place to start. Import it in Eclipse and check the task list to see the TODO list.

If you're lazy, here are the steps :

h3. Overview

!https://github.com/novoda/ImageLoader/raw/master/core/src/main/resources/documentationImage1.png(General overview)!

h3. In the Application class

Add the following code that initialises the image loader:

<pre><code>@Override
public void onCreate() {
    super.onCreate();
    LoaderSettings settings = new SettingsBuilder()
      .withDisconnectOnEveryCall(true).build(this);
    imageManager = new ImageManager(this, settings);
}

public static final ImageManager getImageManager() {
    return imageManager;
}
</code></pre>

h5. LRU cache option

The default cache uses soft references. On a memory-constrained system like Android, space can be reclaimed too often. This limits the performance of the cache. To avoid this problem we added an LruCache implementation. This is really useful when you have lots of small images.

<pre><code>settings = new SettingsBuilder()
  .withCacheManager(new LruBitmapCache(this)).build(this);
thumbnailImageLoader = new ImageManager(this, settings);
</code></pre>

The LruBitmapCache will take 25% of the free memory available for the cache by default. You can change this by using an alternative constructor:

<pre><code>int PERCENTAGE_OF_CACHE = 50;
settings = new SettingsBuilder()
  .withCacheManager(new LruBitmapCache(this, PERCENTAGE_OF_CACHE)).build(this);
thumbnailImageLoader = new ImageManager(this, settings);
</code></pre>

h5. Additional settings

Image loader uses UrlConnection to fetch images. There are two important parameters that UrlConnection uses: connectionTimeout and readTimeout.

<pre><code>SettingsBuilder builder = new SettingsBuilder();
Settings settings = builder.withConnectionTimeout(20000)
  .withReadTimeout(30000).build(this);
</code></pre>

The connection timeout is the timeout in making the initial connection. The read timeout is the timeout on waiting to read data.

h3. In the Activity, Fragment or Adapter

When you need to load the image in a view object you just need to get the image loader from the Application class and call load.
This is an example of a ListView with the binder setting the url in the ImageView as a tag:

<pre><code>ImageTagFactory imageTagFactory = new ImageTagFactory(this, R.drawable.bg_img_loading);
imageTagFactory.setErrorImageId(R.drawable.bg_img_notfound);
...

private ViewBinder getViewBinder() {
  return new ViewBinder() {
    @Override
    public boolean setViewValue(View view, Cursor cursor, int columnIndex) {
      // TODO add this to your class
      ImageTag tag = imageTagFactory.build(cursor.getString(columnIndex))
      ((ImageView) view).setTag(tag);
      imageLoader.load(view);
      return true;
    }
  };
}
</code></pre>

The ImageTagFactory sets up the image loader with the size of the images to display and the loading image to be displayed whilst the real image is fetched. The image loader will fetch the image from the cache (if available), from the SD card, or from the network as a last resort.

h3. Cleaning the SD card cache

If you want ImageLoader to clean up the SD card, you can use the following code in the onCreate of the Application class:

<pre><code>imageManager.getFileManager().clean(this);</code></pre>

In the settings you can edit the expiration period (it defaults to 7 days).

h3. In the AndroidManifest.xml

There are two things you need to add: Permissions and the Service to clean up the files.

<pre><code><uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
</pre></code>

<pre><code><service android:name="com.novoda.imageloader.core.service.CacheCleaner" android:exported="true">
  <intent-filter>
    <action android:name="com.novoda.imageloader.core.action.CLEAN_CACHE" />
  </intent-filter>
</service>
</code></pre>

h3. Cached preview images (optional)

Preview image works well when you have a list of items with small images and you display a larger version of the same image when you click through. 
ImageLoader will take the small picture in the cache (if available) and load it in place of the large image whilst loading the real image.
This can be implemented in two ways: changing the image tag before calling the load method or changing the ImageTagFactory.

<pre><code>// Image tag after normal settings 
imageTag.setPreviewHeight(100);
imageTag.setPreviewHeight(100);
imageTag.setPreviewUrl(previewUrl);
imageView.setTag(imageTag);
getImageManager().getLoader().load(imageView);
</code></pre>

<pre><code>// If small preview image has same url as large image, use ImageTagFactory
imageTagFactory = new ImageTagFactory(this, R.drawable.loading);
imageTagFactory.setErrorImageId(R.drawable.image_not_found);
imageTagFactory.usePreviewImage(THUMB_IMAGE_SIZE, THUMB_IMAGE_SIZE, true);

// On bind 
ImageView imageView = (ImageView) view;
String url = cursor.getString(columnIndex);
imageView.setTag(imageTagFactory.build(url));
ImgSearch.getImageManager().getLoader().load(imageView);
</code></pre>

h3. DirectLoader (utility)

ImageLoader contains a utility class for directly downloading a Bitmap from a URL. This is useful for downloading an image to display in a notification. This does NOT handle threading for you. You should do the download inside an AsyncTask or Thread.

<pre><code>Bitmap myImage = new DirectLoader().download(url);</code></pre>

This method will throw an ImageNotFoundException if there is no image on the other end of your URL.

h2. Getting the library

h3. Using Maven

If you are using Maven you need to define the repo and dependency in your POM:

<pre><code><repositories>
  <repository>
    <id>public-mvn-repo-releases</id>
    <url>https://github.com/novoda/public-mvn-repo/raw/master/releases</url>
  </repository>
</repositories></code></pre>

<pre><code><dependency>
  <groupId>com.novoda.imageloader</groupId>
  <artifactId>imageloader-core</artifactId>
 <version>1.5.5</version>
</dependency></code></pre>

h3. As a .jar

You can also simply include the "latest version":https://github.com/novoda/public-mvn-repo/raw/master/releases/com/novoda/imageloader/imageloader-core/1.5.5/imageloader-core-1.5.5.jar of the .jar file (v 1.5.5) in you project.

h2. Helping out

Novoda <3 open source.

h3. Report issues

If you have a problem with the library or want to suggest new features, let us know by creating an issue in GitHub.

h3. Get involved

If you don't want to wait for us to fix a bug or implement a new feature, you can contribute to the project. To do that fork the repo and when the change is done raise a pull request.

"Find out more about pull requests":https://help.github.com/articles/using-pull-requests

h3. Project structure

* core: simple maven java project
* demo: Android project to test ImageLoader
* acceptance: Android project for Robotium instrumentation tests

h3. Building the projects with maven

Maven: <code>mvn clean install</code>

Note : By default we run instrumentation tests, if you don't attach a device the build will fail at the end.

h3. Eclipse

An easy way to set up the project for eclipse is the following: 

* run <code>mvn clean install -Peclipse</code>. This command copies the dependencies to libs for working in Eclipse. The demo and acceptance projects should be configured as Android projects.
* import the core project as maven project
* create new android project from sources and target the demo folder
* create new android project from sources and target the acceptance folder

h3. IntelliJ

Import as a Maven project from the project root.

h3. Requirements

* Maven 3.0.3+

h2. License

Copyright (c) 2012 Novoda Ltd.
Released under the Apache License, Version 2.0